import telebot
from telebot import types
import sqlite3
import re
import datetime
import os
import threading
import logging
import time
import io
import pandas as pd
import json
import concurrent.futures
import secrets
import string
from datetime import timedelta
import libtorrent as lt  # Torrentæ”¯æŒ
import zipfile
import py7zr
import magic
from dotenv import load_dotenv
import hashlib
import shutil
import psutil
import re
from collections import defaultdict

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

# é…ç½®
API_TOKEN = os.getenv('API_TOKEN', '7728956687:AAG7glfXZh6ZMWbGqr-6mxGK__BfxIFWxY8')
ADMIN_ID = os.getenv('ADMIN_ID', '8027790214')  # ç®¡ç†å‘˜ID
LOG_CHANNEL = int(os.getenv('LOG_CHANNEL', -1007728956687))  # æ—¥å¿—é¢‘é“
CHANNEL_ID = int(os.getenv('CHANNEL_ID', -10012345678))  # å­˜å‚¨é¢‘é“ID
USE_LOCAL_STORAGE = os.getenv('USE_LOCAL_STORAGE', 'False').lower() == 'true'
LOCAL_STORAGE_PATH = os.getenv('LOCAL_STORAGE_PATH', '/data/files')
MAX_FILE_SIZE = int(os.getenv('MAX_FILE_SIZE', 2000000000))  # 2GB
ALLOWED_EXTENSIONS = os.getenv('ALLOWED_EXTENSIONS', 'txt,csv,xlsx,zip,7z,001,r\d+').split(',')

bot = telebot.TeleBot(API_TOKEN)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# VIPç‰¹æƒé…ç½®
VIP_PRIVILEGES = {
    "daily_bonus": 30,  # æ¯æ—¥ç­¾åˆ°é¢å¤–å¥–åŠ±
    "query_discount": 0.7,  # æŸ¥è¯¢æŠ˜æ‰£ç‡
    "batch_limit": 5000,  # æ‰¹é‡æŸ¥è¯¢è¡Œæ•°é™åˆ¶
    "custom_commands": True  # æ˜¯å¦å…è®¸è‡ªå®šä¹‰å‘½ä»¤
}

# åˆ†å·æ£€æµ‹æ¨¡å¼
VOLUME_PATTERNS = [
    r'\.part(\d+)\.', 
    r'\.r(\d+)$',
    r'\.z(\d+)$',
    r'\.(\d{3})$'
]

volume_cache = defaultdict(list)

# æ•°æ®åº“åˆå§‹åŒ–
def init_db():
    conn = sqlite3.connect('soc_data.db', check_same_thread=False)
    c = conn.cursor()
    
    # ç”¨æˆ·è¡¨ï¼ˆå¢åŠ vipå­—æ®µï¼‰
    c.execute('''CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        username TEXT,
        credits INTEGER DEFAULT 0,
        last_checkin DATE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        vip_expiry TIMESTAMP DEFAULT NULL,
        total_redeemed INTEGER DEFAULT 0,
        last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP  -- æ–°å¢æœ€åæ´»è·ƒæ—¶é—´å­—æ®µ
    )''')
    
    # æŸ¥è¯¢æ—¥å¿—è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS query_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        command TEXT,
        params TEXT,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        cost INTEGER
    )''')
    
    # æ•°æ®ä¸Šä¼ è®°å½•
    c.execute('''CREATE TABLE IF NOT EXISTS data_uploads (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        file_name TEXT,
        record_count INTEGER,
        upload_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        status TEXT DEFAULT 'pending'
    )''')
    
    # å‘½ä»¤æ¶ˆè€—è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS command_costs (
        command TEXT PRIMARY KEY,
        cost INTEGER
    )''')
    
    # æ‰¹é‡æŸ¥è¯¢ä»»åŠ¡è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS batch_tasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        task_type TEXT,
        status TEXT DEFAULT 'pending',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        completed_at TIMESTAMP,
        result_count INTEGER
    )''')
    
    # å¡å¯†ç³»ç»Ÿè¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS recharge_cards (
        card_id TEXT PRIMARY KEY,
        amount INTEGER NOT NULL,
        card_type TEXT CHECK(card_type IN ('credits', 'vip')),
        vip_days INTEGER DEFAULT 0,
        is_used BOOLEAN DEFAULT FALSE,
        used_by INTEGER DEFAULT NULL,
        used_at TIMESTAMP DEFAULT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        created_by INTEGER DEFAULT NULL,
        expires_at TIMESTAMP,
        note TEXT DEFAULT ''
    )''')
    
    # å¡å¯†ä½¿ç”¨è®°å½•è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS card_usage_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        card_id TEXT,
        user_id INTEGER,
        redeemed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        amount INTEGER
    )''')
    
    # æ–°å¢æ–‡ä»¶å…ƒæ•°æ®è¡¨ (Aæ–‡ä»¶åŠŸèƒ½)
    c.execute('''
    CREATE TABLE IF NOT EXISTS files (
        id INTEGER PRIMARY KEY,
        file_id TEXT UNIQUE NOT NULL,
        file_name TEXT NOT NULL,
        data_type TEXT NOT NULL,
        description TEXT,
        tags TEXT,
        auto_tags TEXT,
        upload_time DATETIME DEFAULT CURRENT_TIMESTAMP,
        user_id INTEGER NOT NULL,
        last_renewed DATETIME,
        local_path TEXT,
        channel_msg_id INTEGER,  -- Bæ–‡ä»¶æ–°å¢
        torrent_path TEXT,       -- Bæ–‡ä»¶æ–°å¢
        is_volume BOOLEAN DEFAULT 0,  -- Bæ–‡ä»¶æ–°å¢
        volume_index INTEGER,    -- Bæ–‡ä»¶æ–°å¢
        volume_total INTEGER    -- Bæ–‡ä»¶æ–°å¢
    )''')
    
    # å…¨æ–‡æ£€ç´¢ç´¢å¼• (Aæ–‡ä»¶åŠŸèƒ½)
    c.execute('''
    CREATE VIRTUAL TABLE IF NOT EXISTS search_index USING FTS5(
        file_name, 
        description, 
        tags,
        auto_tags
    )''')
    
    # æ•°æ®ç±»å‹é…ç½®è¡¨ (Aæ–‡ä»¶åŠŸèƒ½)
    c.execute('''
    CREATE TABLE IF NOT EXISTS data_types (
        type_id TEXT PRIMARY KEY,
        format TEXT NOT NULL,
        example TEXT
    )''')
    
    # åˆ†å·ç»„è¡¨ (Bæ–‡ä»¶æ–°å¢)
    c.execute('''
    CREATE TABLE IF NOT EXISTS volume_groups (
        group_id TEXT PRIMARY KEY,
        user_id INTEGER,
        file_name TEXT,
        total_parts INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )''')
    
    # åˆå§‹åŒ–å‘½ä»¤æ¶ˆè€—
    commands = {
        '/qd': 0,     # ç­¾åˆ°å…è´¹
        '/my': 1,     # QQç»‘æ‰‹æœº
        '/qe': 3,     # ç»¼åˆæŸ¥è¯¢
        '/yd': 1,     # äººå£æŸ¥è¯¢
        '/bp': 5,     # Vç»‘äº’æŸ¥
        '/ke': 8,    # é“¶è¡Œå¡
        '/ad': 1,     # IMEIæŸ¥è¯¢
        '/nk': 10,    # ä¸Šæµ·10E
        '/la': 5,    # ç§»åŠ¨å…¨åº“
        '/fo': 1,     # è½¦ä¸»æŸ¥è¯¢
        '/kd': 2,     # å­¦ä¹ é€š
        '/ne': 3,     # æ»´æ»´æ•°æ®
        '/verify': 2, # äºŒè¦ç´ æ ¸éªŒ
        '/batch': 10, # æ‰¹é‡æŸ¥è¯¢
        '/redeem': 0,  # å¡å¯†å…‘æ¢
        '/kn': 0,     # ä¸ªäººä¸­å¿ƒå…è´¹
        '/upload': 0,  # Aæ–‡ä»¶æ–°å¢
        '/search': 0,  # Aæ–‡ä»¶æ–°å¢
        '/renew': 0    # Aæ–‡ä»¶æ–°å¢
    }
    
    for cmd, cost in commands.items():
        c.execute('''INSERT OR IGNORE INTO command_costs (command, cost) 
                     VALUES (?, ?)''', (cmd, cost))
    
    # åˆ›å»ºç´¢å¼•åŠ é€ŸæŸ¥è¯¢
    c.execute("CREATE INDEX IF NOT EXISTS idx_users_credits ON users(credits)")
    c.execute("CREATE INDEX IF NOT EXISTS idx_query_logs_user ON query_logs(user_id)")
    c.execute("CREATE INDEX IF NOT EXISTS idx_query_logs_time ON query_logs(timestamp)")
    c.execute("CREATE INDEX IF NOT EXISTS idx_cards_expiry ON recharge_cards(expires_at)")
    c.execute("CREATE INDEX IF NOT EXISTS idx_files_volume ON files(is_volume)")  # Bæ–‡ä»¶æ–°å¢
    
    conn.commit()
    return conn

conn = init_db()

# ==================== ç§¯åˆ†ç®¡ç†å‡½æ•° ====================
def get_user_credits(user_id):
    c = conn.cursor()
    c.execute("SELECT credits FROM users WHERE user_id = ?", (user_id,))
    result = c.fetchone()
    if result:
        return result[0]
    else:
        # æ–°ç”¨æˆ·è‡ªåŠ¨æ³¨å†Œ
        c.execute("INSERT INTO users (user_id, credits) VALUES (?, ?)", (user_id, 0))
        conn.commit()
        return 0

def update_credits(user_id, amount):
    c = conn.cursor()
    c.execute("UPDATE users SET credits = credits + ? WHERE user_id = ?", (amount, user_id))
    conn.commit()

# æ›´æ–°ç”¨æˆ·æœ€åæ´»è·ƒæ—¶é—´
def update_user_last_active(user_id):
    c = conn.cursor()
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    c.execute("UPDATE users SET last_active = ? WHERE user_id = ?", (now, user_id))
    conn.commit()

def deduct_command_cost(user_id, command):
    c = conn.cursor()
    c.execute("SELECT cost FROM command_costs WHERE command = ?", (command,))
    result = c.fetchone()
    if not result:
        return False, 0
    cost = result[0]
    
    # VIPç”¨æˆ·æŠ˜æ‰£
    if is_vip_user(user_id):
        cost = int(cost * VIP_PRIVILEGES["query_discount"])
    
    current_credits = get_user_credits(user_id)
    if current_credits < cost:
        return False, cost
    
    update_credits(user_id, -cost)
    return True, cost

# VIPçŠ¶æ€æ£€æŸ¥
def is_vip_user(user_id):
    c = conn.cursor()
    c.execute("SELECT vip_expiry FROM users WHERE user_id = ?", (user_id,))
    result = c.fetchone()
    if result and result[0]:
        expiry = datetime.datetime.fromisoformat(result[0])
        return expiry > datetime.datetime.now()
    return False

# ==================== åˆ†å·ä¸Šä¼ æ ¸å¿ƒåŠŸèƒ½ (Bæ–‡ä»¶) ====================
def is_volume_file(filename):
    return any(re.search(p, filename) for p in VOLUME_PATTERNS)

def get_volume_info(filename):
    for pattern in VOLUME_PATTERNS:
        match = re.search(pattern, filename)
        if match:
            return {
                'base_name': re.sub(pattern, '', filename),
                'index': int(match.group(1)),
                'total': None  # éœ€è¦åç»­æ£€æµ‹
            }
    return None

def detect_total_parts(group_id):
    # ç®€å•å®ç°ï¼šå‡è®¾åˆ†å·æ€»æ•°æ˜¯æœ€å¤§åºå·
    parts = [vol['index'] for vol in volume_cache[group_id]]
    return max(parts) if parts else 0

def save_to_channel(file_data, file_name):
    try:
        # è½¬å‘åˆ°ç§æœ‰é¢‘é“
        msg = bot.send_document(CHANNEL_ID, file_data, visible_file_name=file_name)
        return msg.message_id
    except Exception as e:
        logging.error(f"é¢‘é“å­˜å‚¨å¤±è´¥: {str(e)}")
        return None

def create_torrent(file_path):
    try:
        fs = lt.file_storage()
        lt.add_files(fs, file_path)
        torrent = lt.create_torrent(fs)
        lt.set_piece_hashes(torrent, os.path.dirname(file_path))
        torrent_path = f"{file_path}.torrent"
        with open(torrent_path, "wb") as f:
            f.write(lt.bencode(torrent.generate()))
        return torrent_path
    except Exception as e:
        logging.error(f"åˆ›å»ºç§å­å¤±è´¥: {str(e)}")
        return None

def process_volume_upload(message):
    try:
        user_id = message.from_user.id
        file_name = message.document.file_name
        volume_info = get_volume_info(file_name)
        
        if not volume_info:
            bot.reply_to(message, "âŒ æ— æ³•è¯†åˆ«åˆ†å·æ ¼å¼")
            return
            
        # åˆ›å»ºåˆ†å·ç»„
        group_id = f"{user_id}_{volume_info['base_name']}"
        if group_id not in volume_cache:
            volume_cache[group_id] = []
            c = conn.cursor()
            c.execute("INSERT INTO volume_groups (group_id, user_id, file_name) VALUES (?, ?, ?)", 
                        (group_id, user_id, volume_info['base_name']))
            conn.commit()
        
        # ä¿å­˜åˆ†å·
        volume_cache[group_id].append({
            'index': volume_info['index'],
            'file_id': message.document.file_id,
            'file_name': file_name
        })
        
        # æ£€æŸ¥æ˜¯å¦å®Œæˆ
        total_parts = detect_total_parts(group_id)
        if len(volume_cache[group_id]) == total_parts:
            threading.Thread(target=merge_and_process, args=(group_id, user_id)).start()
            bot.reply_to(message, f"âœ… æ‰€æœ‰åˆ†å·å·²æ¥æ”¶ï¼å¼€å§‹å¤„ç†åˆå¹¶...")
        else:
            bot.reply_to(message, f"â³ å·²æ¥æ”¶åˆ†å· {len(volume_cache[group_id])}/{total_parts}ï¼Œè¯·ç»§ç»­ä¸Šä¼ ")
            
    except Exception as e:
        bot.reply_to(message, f"âŒ åˆ†å·å¤„ç†é”™è¯¯: {str(e)}")

def merge_and_process(group_id, user_id):
    try:
        # è·å–ç»„ä¿¡æ¯
        group_data = volume_cache[group_id]
        base_name = group_data[0]['base_name']
        
        # æŒ‰åºå·æ’åº
        sorted_volumes = sorted(group_data, key=lambda x: x['index'])
        
        # åˆ›å»ºä¸´æ—¶ç›®å½•
        temp_dir = f"temp_{group_id}"
        os.makedirs(temp_dir, exist_ok=True)
        
        # ä¸‹è½½æ‰€æœ‰åˆ†å·
        for vol in sorted_volumes:
            file_info = bot.get_file(vol['file_id'])
            content = bot.download_file(file_info.file_path)
            part_path = os.path.join(temp_dir, vol['file_name'])
            with open(part_path, 'wb') as f:
                f.write(content)
        
        # åˆå¹¶æ–‡ä»¶
        merged_path = os.path.join(temp_dir, base_name)
        with open(merged_path, 'wb') as outfile:
            for vol in sorted_volumes:
                part_path = os.path.join(temp_dir, vol['file_name'])
                with open(part_path, 'rb') as infile:
                    outfile.write(infile.read())
        
        # å¤„ç†åˆå¹¶åæ–‡ä»¶
        process_large_file(user_id, merged_path, base_name)
        
        # æ¸…ç†ç¼“å­˜
        del volume_cache[group_id]
        shutil.rmtree(temp_dir, ignore_errors=True)
        
        bot.send_message(user_id, f"âœ… {base_name} åˆå¹¶å¤„ç†å®Œæˆï¼")
        
    except Exception as e:
        logging.error(f"åˆ†ç»„åˆå¹¶å¤±è´¥: {str(e)}")
        bot.send_message(user_id, f"âŒ åˆå¹¶å¤±è´¥: {str(e)}")

def process_large_file(user_id, file_path, original_name):
    try:
        # é¢‘é“å­˜å‚¨
        with open(file_path, 'rb') as f:
            channel_msg_id = save_to_channel(f, original_name)
        
        if not channel_msg_id:
            raise Exception("é¢‘é“å­˜å‚¨å¤±è´¥")
        
        # ç”Ÿæˆç§å­
        torrent_path = create_torrent(file_path)
        
        if not torrent_path:
            raise Exception("ç§å­åˆ›å»ºå¤±è´¥")
        
        # ä¿å­˜åˆ°æ•°æ®åº“
        c = conn.cursor()
        c.execute('''
        INSERT INTO files (file_name, user_id, channel_msg_id, torrent_path, is_volume, volume_total)
        VALUES (?, ?, ?, ?, 1, ?)
        ''', (original_name, user_id, channel_msg_id, torrent_path, len(volume_cache.get(f"{user_id}_{original_name}", [])))
        file_id = c.lastrowid
        conn.commit()
        
        # å»ºç«‹å…¨æ–‡ç´¢å¼•
        create_search_index(file_id)
        
        # è¿”å›ç»“æœ
        channel_link = f"https://t.me/c/{str(CHANNEL_ID).replace('-100', '')}/{channel_msg_id}"
        
        # å‘é€ç§å­æ–‡ä»¶
        with open(torrent_path, 'rb') as torrent_file:
            bot.send_document(
                user_id, 
                torrent_file,
                caption=(
                    f"ğŸ“¦ æ–‡ä»¶å­˜å‚¨å®Œæˆï¼\n"
                    f"æ–‡ä»¶å: {original_name}\n"
                    f"ğŸ”— é¢‘é“ä¸‹è½½: {channel_link}\n"
                    f"ğŸ§² ç§å­æ–‡ä»¶å·²é™„åŠ "
                ),
                visible_file_name=f"{original_name}.torrent"
            )
        
        # æœ¬åœ°å­˜å‚¨åå¤‡
        if USE_LOCAL_STORAGE:
            save_file_locally(file_id)
        
    except Exception as e:
        bot.send_message(user_id, f"âŒ å¤§æ–‡ä»¶å¤„ç†å¤±è´¥: {str(e)}")
        logging.error(f"å¤§æ–‡ä»¶å¤„ç†é”™è¯¯: {str(e)}")

# ==================== æ–‡ä»¶ç®¡ç†åŠŸèƒ½ (Aæ–‡ä»¶) ====================
# æ•°æ®ç±»å‹é…ç½®
DATA_TYPES = {
    "qq": {"format": "QQå·,æ‰‹æœºå·,å§“å", "example": "123456,13800138000,å¼ ä¸‰"},
    "id": {"format": "å§“å,èº«ä»½è¯å·", "example": "æå››,110101199001011234"},
    "bank": {"format": "å§“å,é“¶è¡Œå¡å·,å¼€æˆ·è¡Œ", "example": "ç‹äº”,6222021234567890,å·¥å•†é“¶è¡Œ"},
    "vehicle": {"format": "è½¦ç‰Œå·,è½¦æ¶å·,è½¦ä¸»å§“å", "example": "äº¬A12345,LFV2A21KX43000000,èµµå…­"},
    "other": {"format": "è‡ªç”±æ ¼å¼", "example": "ä»»æ„ç»“æ„æ•°æ®"}
}

def save_metadata(metadata):
    c = conn.cursor()
    c.execute('''
    INSERT INTO files (file_id, file_name, data_type, user_id, upload_time)
    VALUES (?, ?, ?, ?, ?)
    ''', (
        metadata['file_id'],
        metadata['file_name'],
        metadata['data_type'],
        metadata['user_id'],
        metadata['upload_time']
    ))
    conn.commit()
    return c.lastrowid

def create_search_index(file_id):
    c = conn.cursor()
    c.execute('''
    SELECT file_name, description, tags, auto_tags 
    FROM files 
    WHERE id = ?
    ''', [file_id])
    file_data = c.fetchone()
    
    if file_data:
        c.execute('''
        INSERT INTO search_index (rowid, file_name, description, tags, auto_tags)
        VALUES (?, ?, ?, ?, ?)
        ''', (file_id, file_data[0], file_data[1], file_data[2], file_data[3]))
        conn.commit()

def get_file_metadata(file_id):
    c = conn.cursor()
    c.execute('SELECT * FROM files WHERE id = ?', [file_id])
    columns = [col[0] for col in c.description]
    data = c.fetchone()
    return dict(zip(columns, data)) if data else None

def get_fresh_link(file_id):
    try:
        file_data = get_file_metadata(file_id)
        if not file_data:
            return "âŒ æ–‡ä»¶ä¸å­˜åœ¨"
        
        # å¦‚æœæ˜¯åˆ†å·æ–‡ä»¶ï¼Œç›´æ¥è¿”å›é¢‘é“é“¾æ¥
        if file_data['is_volume'] and file_data['channel_msg_id']:
            return f"https://t.me/c/{str(CHANNEL_ID).replace('-100', '')}/{file_data['channel_msg_id']}"
        
        file_info = bot.get_file(file_data['file_id'])
        fresh_url = f"https://api.telegram.org/file/bot{API_TOKEN}/{file_info.file_path}"
        
        # æ›´æ–°æœ€åç»­æœŸæ—¶é—´
        c = conn.cursor()
        c.execute('''
        UPDATE files 
        SET last_renewed = ? 
        WHERE id = ?
        ''', (datetime.datetime.now().isoformat(), file_id))
        conn.commit()
        
        return fresh_url
    except Exception as e:
        logging.error(f"è·å–æ–‡ä»¶é“¾æ¥å¤±è´¥: {str(e)}")
        if USE_LOCAL_STORAGE:
            return get_local_file(file_id)
        return "âŒ æ–‡ä»¶é“¾æ¥è·å–å¤±è´¥"

# æœ¬åœ°åå¤‡å­˜å‚¨ç³»ç»Ÿ
def save_file_locally(file_id):
    """å°†æ–‡ä»¶ä¿å­˜åˆ°æœ¬åœ°åå¤‡å­˜å‚¨"""
    try:
        # è·å–æ–‡ä»¶å…ƒæ•°æ®
        file_data = get_file_metadata(file_id)
        if not file_data:
            logging.error(f"æœ¬åœ°å­˜å‚¨å¤±è´¥: æ–‡ä»¶ID {file_id} ä¸å­˜åœ¨")
            return
        
        # ä»TGä¸‹è½½æ–‡ä»¶
        file_info = bot.get_file(file_data['file_id'])
        downloaded_file = bot.download_file(file_info.file_path)
        
        # åˆ›å»ºå­˜å‚¨ç›®å½•
        os.makedirs(LOCAL_STORAGE_PATH, exist_ok=True)
        
        # ä¿å­˜æ–‡ä»¶
        file_path = os.path.join(LOCAL_STORAGE_PATH, f"{file_data['file_id']}_{file_data['file_name']}")
        with open(file_path, 'wb') as f:
            f.write(downloaded_file)
        
        # è®°å½•æœ¬åœ°å­˜å‚¨è·¯å¾„
        c = conn.cursor()
        c.execute('''
        UPDATE files 
        SET local_path = ? 
        WHERE id = ?
        ''', (file_path, file_id))
        conn.commit()
        
        logging.info(f"æ–‡ä»¶ä¿å­˜åˆ°æœ¬åœ°: {file_path}")
    except Exception as e:
        logging.error(f"æœ¬åœ°å­˜å‚¨å¤±è´¥: {str(e)}")

def get_local_file(file_id):
    """ä»æœ¬åœ°å­˜å‚¨è·å–æ–‡ä»¶"""
    c = conn.cursor()
    c.execute('SELECT local_path FROM files WHERE id = ?', [file_id])
    result = c.fetchone()
    
    if result and result[0] and os.path.exists(result[0]):
        return result[0]
    return "âŒ æœ¬åœ°æ–‡ä»¶ä¸å­˜åœ¨"

def generate_auto_tags(file_name):
    """ä»æ–‡ä»¶åç”Ÿæˆè‡ªåŠ¨æ ‡ç­¾"""
    tags = []
    
    # è¯†åˆ«å¸¸è§å…³é”®è¯
    keywords = {
        'QQ': ['qq', 'ä¼é¹…'],
        'ID': ['èº«ä»½è¯', 'id', 'è¯ä»¶'],
        'Bank': ['é“¶è¡Œ', 'é“¶è¡Œå¡', 'è´¦æˆ·'],
        'Phone': ['æ‰‹æœº', 'ç”µè¯', 'å·ç '],
        'Vehicle': ['è½¦ç‰Œ', 'è½¦è¾†', 'è½¦ä¸»']
    }
    
    for tag, patterns in keywords.items():
        for pattern in patterns:
            if pattern.lower() in file_name.lower():
                tags.append(tag)
                break
    
    # è¯†åˆ«æ—¥æœŸ
    date_match = re.search(r'(\d{4})[-_]?(\d{2})[-_]?(\d{2})', file_name)
    if date_match:
        tags.append(f"æ—¥æœŸ:{date_match.group()}")
    
    # è¯†åˆ«åœ°åŒº
    regions = ['åŒ—äº¬', 'ä¸Šæµ·', 'å¹¿å·', 'æ·±åœ³', 'æ±Ÿè‹', 'æµ™æ±Ÿ', 'å¹¿ä¸œ']
    for region in regions:
        if region in file_name:
            tags.append(f"åœ°åŒº:{region}")
    
    return ','.join(set(tags)) if tags else "æœªåˆ†ç±»"

# ==================== æ–‡ä»¶ä¸Šä¼ å‘½ä»¤ ====================
@bot.message_handler(commands=['upload'])
def handle_upload(message):
    user_id = message.from_user.id
    
    # éªŒè¯ç®¡ç†å‘˜æƒé™
    if str(user_id) != ADMIN_ID:
        bot.reply_to(message, "âŒ ä»…ç®¡ç†å‘˜å¯ä¸Šä¼ æ–‡ä»¶")
        return
    
    # è§£æä¸Šä¼ å‘½ä»¤
    args = message.text.split()
    if len(args) < 2:
        return show_upload_help(message)
    
    data_type = args[1].lower()
    if data_type not in DATA_TYPES:
        bot.reply_to(message, f"âŒ æ— æ•ˆæ•°æ®ç±»å‹ï¼Œå¯ç”¨: {', '.join(DATA_TYPES.keys())}")
        return
    
    # ä¿å­˜ä¸Šä¼ ç±»å‹åˆ°ä¸Šä¸‹æ–‡
    bot.reply_to(
        message,
        f"ğŸ”¼ è¯·å‘é€ {data_type} æ•°æ®æ–‡ä»¶ (æ”¯æŒ: TXT, CSV, XLSX, ZIP, 7Z)\n"
        f"æ ¼å¼è¦æ±‚: {DATA_TYPES[data_type]['format']}"
    )
    bot.register_next_step_handler(message, process_file_upload, data_type)

def show_upload_help(message):
    help_text = (
        "ğŸ“¤ æ–‡ä»¶ä¸Šä¼ ä½¿ç”¨è¯´æ˜:\n\n"
        "å‘½ä»¤æ ¼å¼: `/upload æ•°æ®ç±»å‹`\n"
        "å¯ç”¨æ•°æ®ç±»å‹:\n"
    )
    for dtype, info in DATA_TYPES.items():
        help_text += f"- {dtype}: {info['format']} (ç¤ºä¾‹: {info['example']})\n"
    
    bot.reply_to(message, help_text, parse_mode='Markdown')

def process_file_upload(message, data_type):
    user_id = message.from_user.id
    if not message.document:
        bot.reply_to(message, "âŒ è¯·å‘é€æ–‡ä»¶é™„ä»¶")
        return
    
    file_info = bot.get_file(message.document.file_id)
    file_name = message.document.file_name
    file_ext = file_name.split('.')[-1].lower() if '.' in file_name else ''
    
    # éªŒè¯æ–‡ä»¶ç±»å‹
    if file_ext not in ALLOWED_EXTENSIONS:
        bot.reply_to(message, f"âŒ ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: {file_ext}")
        return
    
    # æ£€æŸ¥æ–‡ä»¶å¤§å° - ç®¡ç†å‘˜æ— é™åˆ¶
    # if file_info.file_size > MAX_FILE_SIZE:
    #     bot.reply_to(message, f"âŒ æ–‡ä»¶è¿‡å¤§ ({file_info.file_size/1024/1024:.2f}MB > {MAX_FILE_SIZE/1024/1024}MB)")
    #     return
    
    # æå–å…ƒæ•°æ®
    metadata = {
        'file_id': file_info.file_id,
        'file_name': file_name,
        'data_type': data_type,
        'user_id': user_id,
        'upload_time': datetime.datetime.now().isoformat()
    }
    
    # å­˜å‚¨å…ƒæ•°æ®
    file_id = save_metadata(metadata)
    
    # è¯·æ±‚è¡¥å……æè¿°
    bot.reply_to(
        message,
        "ğŸ“ è¯·æ·»åŠ æ–‡ä»¶æè¿°å’Œæ ‡ç­¾ (ç”¨é€—å·åˆ†éš”):\n"
        "ç¤ºä¾‹: å®¢æˆ·æ•°æ®2023, æ‰‹æœºå·, èº«ä»½è¯å·"
    )
    bot.register_next_step_handler(message, process_file_description, file_id)

def process_file_description(message, file_id):
    text = message.text
    
    # è§£ææè¿°å’Œæ ‡ç­¾
    if ',' in text:
        description, tags = text.split(',', 1)
    else:
        description, tags = text, ""
    
    # æ›´æ–°æ•°æ®åº“
    c = conn.cursor()
    c.execute('''
    UPDATE files 
    SET description = ?, tags = ?, auto_tags = ?
    WHERE id = ?
    ''', (
        description.strip(),
        tags.strip(),
        generate_auto_tags(message.document.file_name),
        file_id
    ))
    conn.commit()
    
    # å»ºç«‹å…¨æ–‡ç´¢å¼•
    create_search_index(file_id)
    
    # æœ¬åœ°å­˜å‚¨åå¤‡
    if USE_LOCAL_STORAGE:
        save_file_locally(file_id)
    
    bot.reply_to(message, "âœ… æ–‡ä»¶å·²æˆåŠŸç´¢å¼•!")

# ==================== æ–‡ä»¶æ£€ç´¢å‘½ä»¤ ====================
@bot.message_handler(commands=['search'])
def handle_search(message):
    query = ' '.join(message.text.split()[1:])
    if not query:
        bot.reply_to(message, "ğŸ” è¯·è¾“å…¥æœç´¢å…³é”®è¯")
        return
    
    # æ‰§è¡Œå…¨æ–‡æ£€ç´¢
    c = conn.cursor()
    c.execute('''
    SELECT rowid, file_name, description, is_volume, channel_msg_id 
    FROM search_index 
    JOIN files ON search_index.rowid = files.id
    WHERE search_index MATCH ?
    ORDER BY rank
    LIMIT 10
    ''', [query])
    results = c.fetchall()
    
    if not results:
        bot.reply_to(message, "âŒ æœªæ‰¾åˆ°åŒ¹é…æ–‡ä»¶")
        return
    
    # æ ¼å¼åŒ–ç»“æœ
    response = "ğŸ” æœç´¢ç»“æœ:\n\n"
    for idx, row in enumerate(results):
        file_id, file_name, description, is_volume, channel_msg_id = row
        fresh_url = get_fresh_link(file_id)
        
        if is_volume:
            response += f"{idx+1}. ğŸ“¦ [åˆ†å·æ–‡ä»¶] {file_name}\n"
            response += f"   - {description}\n"
            if channel_msg_id:
                channel_link = f"https://t.me/c/{str(CHANNEL_ID).replace('-100', '')}/{channel_msg_id}"
                response += f"   ğŸ”— é¢‘é“ä¸‹è½½: {channel_link}\n"
            response += f"   ğŸ§² ç§å­è·å–: /get_torrent_{file_id}\n\n"
        else:
            response += f"{idx+1}. {file_name}\n"
            response += f"   - {description}\n"
            response += f"   ğŸ”— ä¸‹è½½é“¾æ¥: {fresh_url}\n\n"
    
    bot.reply_to(message, response)

# ç§å­è·å–å‘½ä»¤ (Bæ–‡ä»¶æ–°å¢)
@bot.message_handler(regexp=r'/get_torrent_(\d+)')
def send_torrent(message):
    try:
        file_id = re.search(r'/get_torrent_(\d+)', message.text).group(1)
        c = conn.cursor()
        c.execute("SELECT torrent_path, file_name FROM files WHERE id = ?", (file_id,))
        result = c.fetchone()
        
        if result and result[0] and os.path.exists(result[0]):
            with open(result[0], 'rb') as f:
                bot.send_document(
                    message.chat.id, 
                    f,
                    visible_file_name=f"{result[1]}.torrent"
                )
        else:
            bot.reply_to(message, "âŒ ç§å­æ–‡ä»¶ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ")
    except Exception as e:
        bot.reply_to(message, f"âŒ è·å–ç§å­å¤±è´¥: {str(e)}")

# ==================== ä¸»æœºå™¨äººåŠŸèƒ½ ====================
# æ™ºèƒ½å¼•å¯¼é”®ç›˜ - æ·»åŠ ä¸ªäººä¸­å¿ƒæŒ‰é’®
def create_main_keyboard():
    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    buttons = [
        "ğŸ“… ç­¾åˆ° /qd", "ğŸ” ç»¼åˆæŸ¥è¯¢ /qe",
        "ğŸ‘¤ äººå£æŸ¥è¯¢ /yd", "ğŸ“± QQç»‘æ‰‹æœº /my",
        "ğŸ’³ é“¶è¡Œå¡ /ke", "ğŸš— è½¦ä¸»æŸ¥è¯¢ /fo",
        "ğŸ“Š æˆ‘çš„ç§¯åˆ† /credits", "ğŸ‘¤ ä¸ªäººä¸­å¿ƒ /kn",  # æ–°å¢ä¸ªäººä¸­å¿ƒæŒ‰é’®
        "ğŸ”„ æ‰¹é‡æŸ¥è¯¢ /batch", "âœ… äºŒè¦ç´ æ ¸éªŒ /verify",
        "ğŸ« å¡å¯†å…‘æ¢ /redeem", "ğŸ” æ–‡ä»¶æœç´¢ /search"  # æ–°å¢æ–‡ä»¶æœç´¢
    ]
    markup.add(*buttons)
    return markup

def create_admin_keyboard():
    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    buttons = [
        "ğŸ“Š ç³»ç»ŸçŠ¶æ€ /stats",
        "ğŸ“¤ æ•°æ®æ›´æ–° /update_data",
        "ğŸ”„ é‡ç½®ç§¯åˆ† /reset_credits",
        "ğŸ“ å‘é€å…¬å‘Š /announce",
        "ğŸ“‹ æ‰¹é‡ä»»åŠ¡ /batch_tasks",
        "ğŸ”‘ å¡å¯†ç®¡ç† /cardadmin",
        "ğŸ“ æ–‡ä»¶ä¸Šä¼  /upload"  # ç®¡ç†å‘˜æ–°å¢æ–‡ä»¶ä¸Šä¼ 
    ]
    markup.add(*buttons)
    return markup

# æ–‡ä»¶ä¸Šä¼ å¤„ç† (æ”¯æŒæ‰¹é‡æŸ¥è¯¢å’Œæ•°æ®æ›´æ–°)
@bot.message_handler(content_types=['document'])
def handle_document(message):
    user_id = message.from_user.id
    file_info = bot.get_file(message.document.file_id)
    file_name = message.document.file_name
    
    # æ›´æ–°ç”¨æˆ·æœ€åæ´»è·ƒæ—¶é—´
    update_user_last_active(user_id)
    
    # æ£€æŸ¥æ–‡ä»¶ç±»å‹
    if not any(file_name.lower().endswith(ext) for ext in ALLOWED_EXTENSIONS):
        bot.reply_to(message, "âŒ ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼")
        return
    
    # åˆ¤æ–­æ˜¯å¦ä¸ºåˆ†å·æ–‡ä»¶ (Bæ–‡ä»¶)
    if is_volume_file(file_name):
        process_volume_upload(message)
        return
    
    # æ£€æŸ¥æ–‡ä»¶å¤§å° - ç®¡ç†å‘˜æ— é™åˆ¶
    # if file_info.file_size > MAX_FILE_SIZE:
    #     bot.reply_to(message, f"âŒ æ–‡ä»¶è¶…è¿‡5MBé™åˆ¶")
    #     return
    
    try:
        # ä¸‹è½½æ–‡ä»¶å†…å®¹
        downloaded_file = bot.download_file(file_info.file_path)
        file_content = io.BytesIO(downloaded_file)
        
        # åˆ¤æ–­ä¸Šä¼ ç±»å‹ (æ‰¹é‡æŸ¥è¯¢æˆ–æ•°æ®æ›´æ–°)
        if message.caption and '/batch' in message.caption:
            # æ‰¹é‡æŸ¥è¯¢ä»»åŠ¡
            max_lines = VIP_PRIVILEGES["batch_limit"] if is_vip_user(user_id) else 1000
            line_count = len(downloaded_file.splitlines())
            
            if line_count > max_lines:
                bot.reply_to(
                    message,
                    f"âŒ æ–‡ä»¶è¡Œæ•°è¶…è¿‡é™åˆ¶ ({line_count} > {max_lines})\n"
                    f"æ™®é€šç”¨æˆ·æœ€å¤š1000è¡Œï¼ŒVIPç”¨æˆ·å¯å¤„ç†{max_lines}è¡Œ"
                )
                return
            
            c = conn.cursor()
            c.execute(
                "INSERT INTO batch_tasks (user_id, task_type, status) VALUES (?, ?, ?)",
                (user_id, 'query', 'pending')
            )
            task_id = c.lastrowid
            conn.commit()
            
            # å¯åŠ¨åå°å¤„ç†
            threading.Thread(target=process_batch_query, args=(task_id, downloaded_file)).start()
            
            bot.reply_to(
                message,
                f"âœ… æ‰¹é‡æŸ¥è¯¢ä»»åŠ¡å·²æ¥æ”¶!\n"
                f"ä»»åŠ¡ID: `{task_id}`\n"
                f"æ–‡ä»¶å: {file_name}\n"
                f"ç³»ç»Ÿæ­£åœ¨åå°å¤„ç†ï¼Œå¤„ç†å®Œæˆåä¼šé€šçŸ¥æ‚¨\n"
                f"é¢„è®¡å¤„ç†æ—¶é—´: {line_count//50}åˆ†é’Ÿ",
                parse_mode='Markdown'
            )
            
        elif str(user_id) == ADMIN_ID:
            # æ•°æ®æ›´æ–°ä»»åŠ¡
            c = conn.cursor()
            c.execute(
                "INSERT INTO data_uploads (user_id, file_name) VALUES (?, ?)",
                (user_id, file_name)
            )
            upload_id = c.lastrowid
            conn.commit()
            
            # å¯åŠ¨åå°å¤„ç†
            threading.Thread(target=process_uploaded_data, args=(upload_id, downloaded_file)).start()
            
            bot.reply_to(
                message,
                f"âœ… æ•°æ®æ–‡ä»¶æ¥æ”¶æˆåŠŸ!\n"
                f"æ–‡ä»¶å: {file_name}\n"
                f"ç³»ç»Ÿæ­£åœ¨åå°å¤„ç†ï¼Œè¯·ç¨åä½¿ç”¨ /status {upload_id} æŸ¥çœ‹è¿›åº¦"
            )
        else:
            bot.reply_to(message, "âŒ ä»…ç®¡ç†å‘˜å¯ä¸Šä¼ æ•°æ®æ–‡ä»¶")
        
    except Exception as e:
        bot.reply_to(message, f"âŒ æ–‡ä»¶å¤„ç†å¤±è´¥: {str(e)}")

# ==================== å‘½ä»¤å¤„ç† - æ ¸å¿ƒåŠŸèƒ½ ====================
@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    user_id = message.from_user.id
    username = message.from_user.username or str(user_id)
    
    # æ›´æ–°ç”¨æˆ·æ´»è·ƒæ—¶é—´
    update_user_last_active(user_id)
    
    # æ£€æŸ¥ç”¨æˆ·æƒé™
    keyboard = create_main_keyboard()
    if str(user_id) == ADMIN_ID:
        keyboard = create_admin_keyboard()
    
    # æ£€æŸ¥VIPçŠ¶æ€
    vip_status = ""
    if is_vip_user(user_id):
        c = conn.cursor()
        c.execute("SELECT vip_expiry FROM users WHERE user_id = ?", (user_id,))
        expiry_result = c.fetchone()
        if expiry_result and expiry_result[0]:
            expiry = expiry_result[0].split('.')[0]  # æ­£ç¡®å¤„ç†æ—¶é—´æ ¼å¼
            vip_status = f"\nğŸŒŸ *æ‚¨æ˜¯å°Šè´µçš„VIPä¼šå‘˜* (æœ‰æ•ˆæœŸè‡³ {expiry})"
    
    welcome_msg = (
        f"ğŸ‘‹ æ¬¢è¿ *{username}* ä½¿ç”¨è€çš®ç¤¾å·¥åº“æœºå™¨äººï¼{vip_status}\n\n"
        "ğŸ” *ä½¿ç”¨æŒ‡å—*\n"
        "1. æ¯æ—¥ç­¾åˆ°è·å–ç§¯åˆ† ğŸ’°\n"
        "2. ä½¿ç”¨å‘½ä»¤æŸ¥è¯¢æ•°æ® ğŸ”\n"
        "3. æŸ¥è¯¢ä¼šæ¶ˆè€—ç›¸åº”ç§¯åˆ†\n\n"
        "âœ¨ *æ–°å¢åŠŸèƒ½*\n"
        "â€¢ /verify - äºŒè¦ç´ æ ¸éªŒ(å§“å+èº«ä»½è¯)\n"
        "â€¢ /batch - æ‰¹é‡æŸ¥è¯¢(ä¸Šä¼ CSVæ–‡ä»¶)\n"
        "â€¢ /redeem - å¡å¯†å…‘æ¢ç§¯åˆ†æˆ–VIP\n"
        "â€¢ /kn - ä¸ªäººä¸­å¿ƒ\n"
        "â€¢ /search - æ–‡ä»¶æ£€ç´¢ç³»ç»Ÿ\n\n"
        "ğŸ“‹ *å¯ç”¨å‘½ä»¤*\n"
        "â€¢ /qd - æ¯æ—¥ç­¾åˆ°\n"
        "â€¢ /my [QQå·] [æ‰‹æœºå·] - QQç»‘æ‰‹æœºæŸ¥è¯¢\n"
        "â€¢ /qe [ä¿¡æ¯] - ç»¼åˆæŸ¥è¯¢\n"
        "â€¢ /yd [å§“å] [åŸå¸‚] - äººå£æŸ¥è¯¢\n"
        "â€¢ /bp [wxid] [æ‰‹æœºå·] - Vä¿¡ç»‘å®šæŸ¥è¯¢\n"
        "â€¢ /ke [èº«ä»½è¯] [é“¶è¡Œå¡å·] - é“¶è¡Œå¡æŸ¥è¯¢\n"
        "â€¢ /ad [IMEIç ] - æ‰‹æœºè®¾å¤‡æŸ¥è¯¢\n"
        "â€¢ /nk [å§“å] [æ‰‹æœº] [èº«ä»½è¯] - ä¸Šæµ·10EæŸ¥è¯¢\n"
        "â€¢ /la [æ‰‹æœº] [èº«ä»½è¯] - ç§»åŠ¨å…¨åº“æŸ¥è¯¢\n"
        "â€¢ /fo [è½¦ç‰Œ/è½¦æ¶å·] - è½¦ä¸»æŸ¥è¯¢\n"
        "â€¢ /kd [è´¦å·] [å§“å] [æ‰‹æœº] - å­¦ä¹ é€šæŸ¥è¯¢\n"
        "â€¢ /ne [æ‰‹æœº] [èº«ä»½è¯] - æ»´æ»´æ•°æ®æŸ¥è¯¢\n"
        "â€¢ /verify [å§“å] [èº«ä»½è¯å·] - äºŒè¦ç´ æ ¸éªŒ\n"
        "â€¢ /batch - æ‰¹é‡æŸ¥è¯¢(ä¸Šä¼ CSV)\n"
        "â€¢ /redeem [å¡å·] - å…‘æ¢å¡å¯†\n"
        "â€¢ /kn - ä¸ªäººä¸­å¿ƒ\n"
        "â€¢ /search [å…³é”®è¯] - æ–‡ä»¶æ£€ç´¢\n\n"
        "ğŸ *å¡å¯†è´­ä¹°é€šé“*  \n"
        "[ç‚¹å‡»è¿›å…¥å¡ç½‘](æ‚¨çš„åº—é“ºé“¾æ¥)  \n"
        "ğŸ”¥ å½“å‰å¯è´­ï¼š  \n"
        "- 1000ç§¯åˆ†å¡ Â¥10  \n"
        "- æœˆVIPå¡ Â¥50 (äº«æŸ¥è¯¢7æŠ˜+æ‰¹é‡ç‰¹æƒ)  \n"
        "âš ï¸ å…‘æ¢å‘½ä»¤ï¼š/redeem å¡å·  \n\n"
        "ğŸ‘‰ ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹ä½¿ç”¨ï¼"
    )
    
    bot.send_message(
        message.chat.id,
        welcome_msg,
        parse_mode='Markdown',
        reply_markup=keyboard
    )
    
    # è®°å½•æ–°ç”¨æˆ·
    c = conn.cursor()
    c.execute("INSERT OR IGNORE INTO users (user_id, username) VALUES (?, ?)", 
              (user_id, username))
    conn.commit()

# ==================== å…¶ä»–æ ¸å¿ƒåŠŸèƒ½ ====================
# ä¸ªäººä¸­å¿ƒå‘½ä»¤
@bot.message_handler(commands=['kn'])
def user_profile(message):
    user_id = message.from_user.id
    username = message.from_user.username or str(user_id)
    
    # æ›´æ–°ç”¨æˆ·æœ€åæ´»è·ƒæ—¶é—´
    update_user_last_active(user_id)
    
    # è·å–ç”¨æˆ·æ•°æ®
    c = conn.cursor()
    c.execute("SELECT credits, vip_expiry, last_active, total_redeemed FROM users WHERE user_id = ?", (user_id,))
    user_data = c.fetchone()
    
    if not user_data:
        bot.reply_to(message, "âŒ ç”¨æˆ·æ•°æ®ä¸å­˜åœ¨")
        return
    
    credits, vip_expiry, last_active, total_redeemed = user_data
    
    # æ ¼å¼åŒ–VIPçŠ¶æ€
    vip_status = "æ™®é€šç”¨æˆ·"
    if vip_expiry and datetime.datetime.fromisoformat(vip_expiry) > datetime.datetime.now():
        expiry = vip_expiry.split('.')[0]  # æ­£ç¡®å¤„ç†æ—¶é—´æ ¼å¼
        vip_status = f"ğŸŒŸ VIPä¼šå‘˜ (æœ‰æ•ˆæœŸè‡³ {expiry})"
    
    # æ ¼å¼åŒ–æœ€åæ´»è·ƒæ—¶é—´
    last_active_str = last_active.split('.')[0] if last_active else "æœªçŸ¥"
    
    # åˆ›å»ºä¸ªäººä¸­å¿ƒé¢æ¿
    profile_msg = (
        f"ğŸ‘¤ *ä¸ªäººä¸­å¿ƒ* - @{username}\n\n"
        f"ğŸ†” ç”¨æˆ·ID: `{user_id}`\n"
        f"ğŸ’° å½“å‰ç§¯åˆ†: *{credits}*\n"
        f"ğŸ« è´¦æˆ·çŠ¶æ€: {vip_status}\n"
        f"â± æœ€åæ´»è·ƒ: {last_active_str}\n"
        f"ğŸ ç´¯è®¡å……å€¼: {total_redeemed}ç§¯åˆ†\n\n"
        "ğŸ“Š *è´¦æˆ·ç»Ÿè®¡*\n"
        "â€¢ ä»Šæ—¥æŸ¥è¯¢: 5æ¬¡\n"
        "â€¢ æœ¬æœˆæŸ¥è¯¢: 32æ¬¡\n"
        "â€¢ ç´¯è®¡æŸ¥è¯¢: 128æ¬¡\n\n"
        "ğŸ’ VIPç‰¹æƒ: æŸ¥è¯¢7æŠ˜ | æ‰¹é‡å¤„ç† | æ¯æ—¥åŒå€ç§¯åˆ†"
    )
    
    # æ·»åŠ æ“ä½œæŒ‰é’®
    markup = types.InlineKeyboardMarkup()
    markup.row(
        types.InlineKeyboardButton("å……å€¼ç§¯åˆ†", callback_data="recharge_credits"),
        types.InlineKeyboardButton("ç»­è´¹VIP", callback_data="renew_vip")
    )
    markup.row(
        types.InlineKeyboardButton("é‚€è¯·å¥½å‹", callback_data="invite_friends"),
        types.InlineKeyboardButton("ä½¿ç”¨è®°å½•", callback_data="usage_history")
    )
    
    bot.send_message(
        message.chat.id,
        profile_msg,
        parse_mode='Markdown',
        reply_markup=markup
    )

@bot.message_handler(commands=['qd'])
def check_in(message):
    user_id = message.from_user.id
    today = datetime.date.today().isoformat()
    
    # æ›´æ–°ç”¨æˆ·æ´»è·ƒæ—¶é—´
    update_user_last_active(user_id)
    
    c = conn.cursor()
    c.execute("SELECT last_checkin FROM users WHERE user_id = ?", (user_id,))
    result = c.fetchone()
    
    if result and result[0] == today:
        bot.reply_to(message, "â° æ‚¨ä»Šå¤©å·²ç»ç­¾åˆ°è¿‡äº†ï¼Œè¯·æ˜å¤©å†æ¥ï¼")
        return
    
    # è®¡ç®—ç­¾åˆ°å¥–åŠ±
    bonus = 15
    if is_vip_user(user_id):
        bonus += VIP_PRIVILEGES["daily_bonus"]
    
    # æ›´æ–°ç­¾åˆ°çŠ¶æ€å’Œç§¯åˆ†
    c.execute("UPDATE users SET last_checkin = ?, credits = credits + ? WHERE user_id = ?", 
              (today, bonus, user_id))
    conn.commit()
    
    # è·å–æœ€æ–°ç§¯åˆ†
    credits = get_user_credits(user_id)
    
    reply_msg = f"âœ… ç­¾åˆ°æˆåŠŸï¼è·å¾— {bonus} ç§¯åˆ†\nğŸ’° å½“å‰æ€»ç§¯åˆ†: {credits}"
    if is_vip_user(user_id):
        reply_msg += "\nğŸ‰ VIPç”¨æˆ·é¢å¤–å¥–åŠ±!"
    
    bot.reply_to(
        message,
        reply_msg,
        reply_markup=create_main_keyboard()
    )

# ==================== æŸ¥è¯¢ç¼“å­˜ä¼˜åŒ– ====================
query_cache = {}
CACHE_EXPIRY = 300  # 5åˆ†é’Ÿç¼“å­˜

def get_cached_query(key):
    now = time.time()
    if key in query_cache:
        cached_time, result = query_cache[key]
        if now - cached_time < CACHE_EXPIRY:
            return result
    return None

def set_cached_query(key, result):
    query_cache[key] = (time.time(), result)

# ==================== æ™ºèƒ½å‘½ä»¤å¤„ç† ====================
def handle_query_command(command, params_pattern):
    def decorator(func):
        @bot.message_handler(commands=[command[1:]])
        def wrapper(message):
            user_id = message.from_user.id
            username = message.from_user.username or str(user_id)
            
            # æ›´æ–°ç”¨æˆ·æ´»è·ƒæ—¶é—´
            update_user_last_active(user_id)
            
            # æ£€æŸ¥ç§¯åˆ†
            success, cost = deduct_command_cost(user_id, command)
            if not success:
                bot.reply_to(
                    message,
                    f"âŒ ç§¯åˆ†ä¸è¶³ï¼éœ€è¦ {cost} ç§¯åˆ†ï¼Œæ‚¨å½“å‰æœ‰ {get_user_credits(user_id)} ç§¯åˆ†\n"
                    "è¯·ç­¾åˆ°æˆ–è”ç³»ç®¡ç†å‘˜å……å€¼"
                )
                return
            
            # è§£æå‚æ•°
            try:
                parts = message.text.split()
                if len(parts) < 2:
                    raise ValueError("ç¼ºå°‘å‚æ•°")
                
                # æå–å‚æ•°
                params = parts[1:]
                if not re.match(params_pattern, " ".join(params)):
                    raise ValueError("å‚æ•°æ ¼å¼é”™è¯¯")
                
                # æ£€æŸ¥ç¼“å­˜
                cache_key = f"{command}:{':'.join(params)}"
                cached_result = get_cached_query(cache_key)
                if cached_result:
                    bot.reply_to(message, cached_result)
                    return
                
                # è®°å½•æŸ¥è¯¢
                c = conn.cursor()
                c.execute(
                    "INSERT INTO query_logs (user_id, command, params, cost) VALUES (?, ?, ?, ?)",
                    (user_id, command, " ".join(params), cost)
                )
                conn.commit()
                
                # æ‰§è¡ŒæŸ¥è¯¢
                result = func(params)
                
                # è®¾ç½®ç¼“å­˜
                set_cached_query(cache_key, result)
                
                # å‘é€ç»“æœ
                bot.reply_to(message, result)
                
                # æ—¥å¿—è®°å½•
                log_msg = (
                    f"ğŸ” æŸ¥è¯¢è®°å½•\n"
                    f"ç”¨æˆ·: @{username}\n"
                    f"å‘½ä»¤: {command}\n"
                    f"å‚æ•°: {' '.join(params)}\n"
                    f"æ¶ˆè€—: {cost}ç§¯åˆ†"
                )
                bot.send_message(LOG_CHANNEL, log_msg)
                
            except Exception as e:
                conn.rollback()
                update_credits(user_id, cost)  # è¿”è¿˜ç§¯åˆ†
                bot.reply_to(
                    message,
                    f"âš ï¸ é”™è¯¯: {str(e)}\n"
                    f"æ­£ç¡®æ ¼å¼: `{command} {params_pattern}`\n"
                    "ç¤ºä¾‹: `{command} {' '.join(params_pattern.split()[:2])}...`",
                    parse_mode='Markdown'
                )
        return wrapper
    return decorator

# ==================== æŸ¥è¯¢å‘½ä»¤å®ç° ====================
# äºŒè¦ç´ æ ¸éªŒåŠŸèƒ½
@handle_query_command('/verify', r'\S+ \d{17}[\dX]')
def id_verification(params):
    name, id_card = params
    # è¿™é‡Œè°ƒç”¨ç¬¬ä¸‰æ–¹APIè¿›è¡Œæ ¸éªŒ
    # æ¨¡æ‹ŸAPIå“åº”
    verification_result = {
        "status": "success",
        "result": "ä¸€è‡´",
        "province": "åŒ—äº¬",
        "birthday": "1990-01-01",
        "gender": "ç”·"
    }
    
    # æ©ç å¤„ç†èº«ä»½è¯å·
    masked_id = id_card[:6] + '*' * 8 + id_card[-4:]
    
    return (
        f"ğŸ†” äºŒè¦ç´ æ ¸éªŒç»“æœ\n\n"
        f"å§“å: *{name}*\n"
        f"èº«ä»½è¯: `{masked_id}`\n"
        f"æ ¸éªŒç»“æœ: âœ… {verification_result['result']}\n"
        f"æ€§åˆ«: {verification_result['gender']}\n"
        f"å‡ºç”Ÿæ—¥æœŸ: {verification_result['birthday']}\n"
        f"çœä»½: {verification_result['province']}"
    )

# æŸ¥è¯¢å‘½ä»¤å®ç°
@handle_query_command('/my', r'\d{5,12} 1\d{10}')
def qq_bind_query(params):
    qq, phone = params
    # æ©ç å¤„ç†æ‰‹æœºå·
    masked_phone = phone[:3] + '****' + phone[-4:]
    
    return (
        f"ğŸ” QQç»‘å®šæŸ¥è¯¢ç»“æœ\n\n"
        f"ğŸ“± QQå·ç : {qq}\n"
        f"ğŸ“ æ‰‹æœºå·: {masked_phone}\n"
        f"ğŸ”— ç»‘å®šçŠ¶æ€: å·²ç»‘å®š\n"
        f"â± ç»‘å®šæ—¶é—´: 2023-08-15\n"
        f"ğŸŒ å½’å±åœ°: å¹¿ä¸œæ·±åœ³"
    )

@handle_query_command('/yd', r'\S+ \S+')
def population_query(params):
    name, city = params
    return (
        f"ğŸ‘¤ äººå£æŸ¥è¯¢ç»“æœ\n\n"
        f"å§“å: {name}\n"
        f"åŸå¸‚: {city}\n"
        f"å¹´é¾„: 32\n"
        f"æ€§åˆ«: ç”·\n"
        f"èº«ä»½è¯: 310***199105******\n"
        f"æˆ·ç±åœ°å€: {city}å¸‚æœé˜³åŒº"
    )

@handle_query_command('/nk', r'\S+ 1\d{10} \d{17}[\dX]')
def shanghai_query(params):
    name, phone, id_card = params
    # æ©ç å¤„ç†æ•æ„Ÿä¿¡æ¯
    masked_phone = phone[:3] + '****' + phone[-4:]
    masked_id = id_card[:6] + '*' * 8 + id_card[-4:]
    
    return (
        f"ğŸ™ ä¸Šæµ·10EæŸ¥è¯¢ç»“æœ\n\n"
        f"å§“å: {name}\n"
        f"æ‰‹æœº: {masked_phone}\n"
        f"èº«ä»½è¯: {masked_id}\n"
        f"ç¤¾ä¿çŠ¶æ€: æ­£å¸¸ç¼´çº³\n"
        f"å…¬ç§¯é‡‘è´¦æˆ·: 3100****\n"
        f"æœ€è¿‘æ´»åŠ¨: 2024-01-15 æµ¦ä¸œæ–°åŒº"
    )

# ==================== ç§¯åˆ†æŸ¥è¯¢ ====================
@bot.message_handler(commands=['credits'])
def show_credits(message):
    user_id = message.from_user.id
    credits = get_user_credits(user_id)
    
    # æ›´æ–°ç”¨æˆ·æ´»è·ƒæ—¶é—´
    update_user_last_active(user_id)
    
    # è·å–VIPçŠ¶æ€
    vip_status = "æ™®é€šç”¨æˆ·"
    if is_vip_user(user_id):
        c = conn.cursor()
        c.execute("SELECT vip_expiry FROM users WHERE user_id = ?", (user_id,))
        expiry_result = c.fetchone()
        if expiry_result and expiry_result[0]:
            expiry = expiry_result[0].split('.')[0]  # æ­£ç¡®å¤„ç†æ—¶é—´æ ¼å¼
            vip_status = f"ğŸŒŸ VIPä¼šå‘˜ (æœ‰æ•ˆæœŸè‡³ {expiry})"
    
    bot.reply_to(
        message,
        f"ğŸ’° æ‚¨çš„å½“å‰ç§¯åˆ†: *{credits}*\n"
        f"ğŸ‘¤ è´¦æˆ·çŠ¶æ€: {vip_status}\n\n"
        "ğŸ“ ç§¯åˆ†è·å–æ–¹å¼:\n"
        "â€¢ æ¯æ—¥ç­¾åˆ°: +15åˆ† (VIP +30åˆ†)\n"
        "â€¢ é‚€è¯·æ–°ç”¨æˆ·: +30åˆ†/äºº\n"
        "â€¢ æ•°æ®è´¡çŒ®: +70åˆ†/æ‰¹\n"
        "â€¢ å¡å¯†å…‘æ¢: /redeem å‘½ä»¤\n\n"
        "ğŸ”„ ç§¯åˆ†æ¯æ—¥0ç‚¹åˆ·æ–°",
        parse_mode='Markdown'
    )

# ==================== å¡å¯†å…‘æ¢åŠŸèƒ½ ====================
@bot.message_handler(commands=['redeem'])
def redeem_card_command(message):
    user_id = message.from_user.id
    text = message.text.strip()
    
    # æ›´æ–°ç”¨æˆ·æ´»è·ƒæ—¶é—´
    update_user_last_active(user_id)
    
    if len(text.split()) < 2:
        bot.reply_to(
            message,
            "ğŸ”‘ *å¡å¯†å…‘æ¢ä½¿ç”¨è¯´æ˜*\n\n"
            "1. è·å–å……å€¼å¡å¯†\n"
            "2. ä½¿ç”¨å‘½ä»¤: `/redeem å¡å¯†å·ç `\n"
            "3. ç³»ç»Ÿä¼šè‡ªåŠ¨è¯†åˆ«å¡å¯†ç±»å‹å¹¶å……å€¼\n\n"
            "ç¤ºä¾‹: `/redeem ABCDEFG123456789`",
            parse_mode='Markdown'
        )
        return
    
    card_id = text.split()[1]
    success, result_msg = redeem_card(user_id, card_id)
    
    if success:
        # è®°å½•æ—¥å¿—
        c = conn.cursor()
        c.execute("INSERT INTO card_usage_logs (card_id, user_id, amount) VALUES (?, ?, ?)",
                  (card_id, user_id, result_msg.split()[1] if "ç§¯åˆ†" in result_msg else 0))
        conn.commit()
        
        # è·å–ç”¨æˆ·å½“å‰ä¿¡æ¯
        credits = get_user_credits(user_id)
        if is_vip_user(user_id):
            c.execute("SELECT vip_expiry FROM users WHERE user_id = ?", (user_id,))
            expiry_result = c.fetchone()
            if expiry_result and expiry_result[0]:
                expiry = expiry_result[0].split('.')[0]  # æ­£ç¡®å¤„ç†æ—¶é—´æ ¼å¼
                result_msg += f"\nğŸ’° å½“å‰ç§¯åˆ†: {credits}\nğŸŒŸ VIPæœ‰æ•ˆæœŸè‡³: {expiry}"
        else:
            result_msg += f"\nğŸ’° å½“å‰ç§¯åˆ†: {credits}"
    
    bot.reply_to(message, result_msg)

# ==================== æ‰¹é‡æŸ¥è¯¢åŠŸèƒ½ ====================
@bot.message_handler(commands=['batch'])
def handle_batch_query(message):
    user_id = message.from_user.id
    username = message.from_user.username or str(user_id)
    
    # æ›´æ–°ç”¨æˆ·æ´»è·ƒæ—¶é—´
    update_user_last_active(user_id)
    
    # æ£€æŸ¥ç§¯åˆ†
    success, cost = deduct_command_cost(user_id, '/batch')
    if not success:
        bot.reply_to(
            message,
            f"âŒ ç§¯åˆ†ä¸è¶³ï¼éœ€è¦ {cost} ç§¯åˆ†ï¼Œæ‚¨å½“å‰æœ‰ {get_user_credits(user_id)} ç§¯åˆ†\n"
            "è¯·ç­¾åˆ°æˆ–è”ç³»ç®¡ç†å‘˜å……å€¼"
        )
        return
    
    # å‘é€ä½¿ç”¨è¯´æ˜å’Œæ¨¡æ¿
    max_lines = VIP_PRIVILEGES["batch_limit"] if is_vip_user(user_id) else 1000
    instructions = (
        f"ğŸ“¤ *æ‰¹é‡æŸ¥è¯¢åŠŸèƒ½* ({'VIPç‰¹æƒ' if is_vip_user(user_id) else 'æ™®é€šç”¨æˆ·'})\n\n"
        f"1. å‡†å¤‡CSVæ–‡ä»¶ï¼Œæ¯è¡Œä¸€ä¸ªæŸ¥è¯¢ä»»åŠ¡ (æœ€å¤š{max_lines}è¡Œ)\n"
        "2. æ–‡ä»¶æ ¼å¼: `å‘½ä»¤,å‚æ•°1,å‚æ•°2,...`\n"
        "3. ç¤ºä¾‹:\n"
        "```\n"
        "/my,123456,13800138000\n"
        "/yd,å¼ ä¸‰,åŒ—äº¬\n"
        "/verify,æå››,110101199001011234\n"
        "```\n"
        "4. ä¸Šä¼ æ–‡ä»¶åç³»ç»Ÿä¼šåå°å¤„ç†\n\n"
        "âš ï¸ æ³¨æ„: æ¯è¡Œæ¶ˆè€—ç›¸åº”å‘½ä»¤ç§¯åˆ†!\n\n"
        "ğŸ“ ä¸‹è½½[æ¨¡æ¿æ–‡ä»¶](https://example.com/batch_template.csv)"
    )
    
    bot.reply_to(
        message,
        instructions,
        parse_mode='Markdown'
    )
    
    # è®°å½•æŸ¥è¯¢
    c = conn.cursor()
    c.execute(
        "INSERT INTO query_logs (user_id, command, params, cost) VALUES (?, ?, ?, ?)",
        (user_id, '/batch', 'init', cost)
    )
    conn.commit()

# ==================== æ‰¹é‡æŸ¥è¯¢å¤„ç† ====================
def process_batch_query(task_id, file_content):
    try:
        c = conn.cursor()
        c.execute("UPDATE batch_tasks SET status = 'processing' WHERE id = ?", (task_id,))
        conn.commit()
        
        # è·å–ä»»åŠ¡ä¿¡æ¯
        c.execute("SELECT user_id FROM batch_tasks WHERE id = ?", (task_id,))
        user_id = c.fetchone()[0]
        
        # å¤„ç†æ–‡ä»¶å†…å®¹
        content = file_content.decode('utf-8')
        lines = content.splitlines()
        
        # å¤„ç†æ¯è¡ŒæŸ¥è¯¢
        results = ["åŸå§‹è¡Œ,ç»“æœ,çŠ¶æ€,æ¶ˆè€—ç§¯åˆ†"]  # æ·»åŠ è¡¨å¤´
        success_count = 0
        error_count = 0
        total_cost = 0
        line_count = len(lines)
        
        # ä½¿ç”¨çº¿ç¨‹æ± å¹¶è¡Œå¤„ç†
        max_workers = 15 if is_vip_user(user_id) else 10
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = []
            for idx, line in enumerate(lines[:1000]):  # é™åˆ¶æœ€å¤§1000è¡Œ
                if not line.strip() or line.startswith('#'):
                    continue
                futures.append(executor.submit(process_query_line, user_id, line))
                
                # æ¯å¤„ç†50è¡Œå‘é€è¿›åº¦æ›´æ–°
                if idx > 0 and idx % 50 == 0:
                    bot.send_message(
                        user_id, 
                        f"â³ æ‰¹é‡å¤„ç†è¿›åº¦: å·²å¤„ç† {idx}/{line_count} è¡Œ"
                    )
            
            for future in concurrent.futures.as_completed(futures):
                result, cost, success, error_msg = future.result()
                if success:
                    results.append(f"{result},{cost}")
                    success_count += 1
                    total_cost += cost
                else:
                    results.append(f"{result},é”™è¯¯: {error_msg},0")
                    error_count += 1
        
        # ç”Ÿæˆç»“æœæ–‡ä»¶
        result_content = "\n".join(results)
        result_file = io.BytesIO(result_content.encode('utf-8'))
        result_file.name = f"batch_result_{task_id}.csv"
        
        # æ›´æ–°ä»»åŠ¡çŠ¶æ€
        c.execute(
            "UPDATE batch_tasks SET status = 'completed', completed_at = CURRENT_TIMESTAMP, result_count = ? WHERE id = ?",
            (success_count, task_id)
        )
        conn.commit()
        
        # é€šçŸ¥ç”¨æˆ·
        bot.send_document(
            user_id,
            result_file,
            caption=(
                f"âœ… æ‰¹é‡æŸ¥è¯¢ä»»åŠ¡å®Œæˆ!\n"
                f"ä»»åŠ¡ID: {task_id}\n"
                f"æˆåŠŸ: {success_count}æ¡\n"
                f"å¤±è´¥: {error_count}æ¡\n"
                f"æ€»æ¶ˆè€—: {total_cost}ç§¯åˆ†"
            )
        )
        
    except Exception as e:
        c.execute("UPDATE batch_tasks SET status = 'failed' WHERE id = ?", (task_id,))
        conn.commit()
        bot.send_message(
            user_id if 'user_id' in locals() else ADMIN_ID,
            f"âŒ æ‰¹é‡æŸ¥è¯¢ä»»åŠ¡å¤±è´¥ (ID:{task_id}): {str(e)}"
        )

def process_query_line(user_id, line):
    try:
        parts = line.strip().split(',')
        if len(parts) < 2:
            return line, 0, False, "å‚æ•°ä¸è¶³"
        
        command = parts[0].strip()
        params = parts[1:]
        
        # æ£€æŸ¥å‘½ä»¤æ˜¯å¦æœ‰æ•ˆ
        c = conn.cursor()
        c.execute("SELECT cost FROM command_costs WHERE command = ?", (command,))
        cost_info = c.fetchone()
        if not cost_info:
            return line, 0, False, "æ— æ•ˆå‘½ä»¤"
        cost = cost_info[0]
        
        # VIPç”¨æˆ·æŠ˜æ‰£
        if is_vip_user(user_id):
            cost = int(cost * VIP_PRIVILEGES["query_discount"])
        
        # æ£€æŸ¥ç§¯åˆ†
        current_credits = get_user_credits(user_id)
        if current_credits < cost:
            return line, 0, False, "ç§¯åˆ†ä¸è¶³"
        
        # æ‰§è¡ŒæŸ¥è¯¢ (æ¨¡æ‹Ÿ)
        # å®é™…åº”ç”¨ä¸­è¿™é‡Œåº”è¯¥è°ƒç”¨ç›¸åº”çš„æŸ¥è¯¢å‡½æ•°
        if command == '/my' and len(params) == 2:
            result = f"QQç»‘å®š,{params[0]},{params[1]},æˆåŠŸ"
        elif command == '/verify' and len(params) == 2:
            result = f"äºŒè¦ç´ æ ¸éªŒ,{params[0]},{params[1]},ä¸€è‡´"
        elif command == '/yd' and len(params) == 2:
            result = f"äººå£æŸ¥è¯¢,{params[0]},{params[1]},æˆåŠŸ"
        else:
            return line, 0, False, "å‘½ä»¤æ ¼å¼é”™è¯¯"
        
        # æ‰£é™¤ç§¯åˆ†
        update_credits(user_id, -cost)
        
        return result, cost, True, ""
        
    except Exception as e:
        return line, 0, False, str(e)

# ==================== å¤„ç†æ•°æ®æ›´æ–° ====================
def process_uploaded_data(upload_id, file_content):
    try:
        c = conn.cursor()
        c.execute("UPDATE data_uploads SET status = 'processing' WHERE id = ?", (upload_id,))
        conn.commit()
        
        # å¤„ç†æ–‡ä»¶å†…å®¹
        content = file_content.decode('utf-8')
        record_count = len(content.splitlines()) - 1  # å‡æ ‡é¢˜è¡Œ
        
        # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
        time.sleep(10)
        
        # æ›´æ–°è®°å½•
        c.execute(
            "UPDATE data_uploads SET status = 'completed', record_count = ? WHERE id = ?",
            (record_count, upload_id)
        )
        conn.commit()
        
        # é€šçŸ¥ç®¡ç†å‘˜
        bot.send_message(
            ADMIN_ID,
            f"âœ… æ•°æ®æ›´æ–°å®Œæˆ!\n"
            f"ID: {upload_id}\n"
            f"è®°å½•æ•°: {record_count}\n"
            f"å¤„ç†æ—¶é—´: 10ç§’"
        )
        
    except Exception as e:
        c.execute("UPDATE data_uploads SET status = 'failed' WHERE id = ?", (upload_id,))
        conn.commit()
        bot.send_message(ADMIN_ID, f"âŒ æ•°æ®å¤„ç†å¤±è´¥ (ID:{upload_id}): {str(e)}")

# ==================== å¡å¯†ç®¡ç†å‘½ä»¤ ====================
@bot.message_handler(commands=['cardadmin'])
def card_admin_menu(message):
    if str(message.from_user.id) != ADMIN_ID:
        return
    
    markup = types.InlineKeyboardMarkup()
    markup.row(
        types.InlineKeyboardButton("ç”Ÿæˆç§¯åˆ†å¡", callback_data="gen_credit_card"),
        types.InlineKeyboardButton("ç”ŸæˆVIPå¡", callback_data="gen_vip_card")
    )
    markup.row(
        types.InlineKeyboardButton("å¡å¯†ç»Ÿè®¡", callback_data="card_stats"),
        types.InlineKeyboardButton("å¯¼å‡ºå¡å¯†", callback_data="export_cards")
    )
    
    bot.send_message(
        message.chat.id,
        "ğŸ”‘ *å¡å¯†ç®¡ç†ç³»ç»Ÿ* - ç®¡ç†å‘˜é¢æ¿\n\n"
        "è¯·é€‰æ‹©æ“ä½œ:",
        parse_mode='Markdown',
        reply_markup=markup
    )

# ==================== å¡å¯†ç®¡ç†å›è°ƒå¤„ç† ====================
@bot.callback_query_handler(func=lambda call: call.data.startswith('gen_') or call.data in ['card_stats', 'export_cards'])
def handle_card_admin_callback(call):
    if str(call.from_user.id) != ADMIN_ID:
        return
    
    if call.data == 'gen_credit_card':
        msg = bot.send_message(
            call.message.chat.id,
            "ğŸª™ ç”Ÿæˆç§¯åˆ†å¡å¯†\n\n"
            "è¯·è¾“å…¥å‚æ•°æ ¼å¼:\n"
            "`ç§¯åˆ†æ•°é‡ ç”Ÿæˆæ•°é‡ [æœ‰æ•ˆæœŸå¤©æ•°=30] [å¤‡æ³¨]`\n\n"
            "ç¤ºä¾‹: `1000 10 60 æ´»åŠ¨èµ é€å¡`",
            parse_mode='Markdown'
        )
        bot.register_next_step_handler(msg, process_gen_credit_card)
    
    elif call.data == 'gen_vip_card':
        msg = bot.send_message(
            call.message.chat.id,
            "ğŸŒŸ ç”ŸæˆVIPå¡å¯†\n\n"
            "è¯·è¾“å…¥å‚æ•°æ ¼å¼:\n"
            "`VIPå¤©æ•° ç”Ÿæˆæ•°é‡ [æœ‰æ•ˆæœŸå¤©æ•°=30] [å¤‡æ³¨]`\n\n"
            "ç¤ºä¾‹: `30 5 90 æœˆåº¦VIPå¡`",
            parse_mode='Markdown'
        )
        bot.register_next_step_handler(msg, process_gen_vip_card)
    
    elif call.data == 'card_stats':
        show_card_stats(call.message)
    
    elif call.data == 'export_cards':
        export_cards(call.message)

def process_gen_credit_card(message):
    try:
        parts = message.text.split()
        if len(parts) < 2:
            raise ValueError("å‚æ•°ä¸è¶³")
        
        amount = int(parts[0])
        count = int(parts[1])
        expires_in = int(parts[2]) if len(parts) > 2 else 30
        note = ' '.join(parts[3:]) if len(parts) > 3 else ''
        
        if count > 100:
            bot.reply_to(message, "âŒ å•æ¬¡æœ€å¤šç”Ÿæˆ100å¼ å¡å¯†")
            return
        
        generated_cards = []
        for _ in range(count):
            card_id = create_recharge_card(amount, 'credits', 0, note, message.from_user.id, expires_in)
            generated_cards.append(card_id)
        
        # ä¿å­˜å¡å¯†åˆ°æ–‡ä»¶
        timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        file_name = f"credit_cards_{timestamp}.txt"
        file_content = "\n".join([f"{card_id} {amount}ç§¯åˆ†" for card_id in generated_cards])
        
        bot.send_document(
            message.chat.id,
            io.BytesIO(file_content.encode('utf-8')),
            caption=(
                f"âœ… æˆåŠŸç”Ÿæˆ {count} å¼ ç§¯åˆ†å¡å¯†!\n"
                f"æ¯å¼ å¡å€¼: {amount}ç§¯åˆ†\n"
                f"æœ‰æ•ˆæœŸ: {expires_in}å¤©\n\n"
                f"ä½¿ç”¨å‘½ä»¤: `/redeem å¡å·`"
            ),
            visible_file_name=file_name
        )
        
    except Exception as e:
        bot.reply_to(message, f"âŒ ç”Ÿæˆå¤±è´¥: {str(e)}")

def process_gen_vip_card(message):
    try:
        parts = message.text.split()
        if len(parts) < 2:
            raise ValueError("å‚æ•°ä¸è¶³")
        
        vip_days = int(parts[0])
        count = int(parts[1])
        expires_in = int(parts[2]) if len(parts) > 2 else 30
        note = ' '.join(parts[3:]) if len(parts) > 3 else ''
        
        if count > 50:
            bot.reply_to(message, "âŒ å•æ¬¡æœ€å¤šç”Ÿæˆ50å¼ VIPå¡å¯†")
            return
        
        generated_cards = []
        for _ in range(count):
            card_id = create_recharge_card(0, 'vip', vip_days, note, message.from_user.id, expires_in)
            generated_cards.append(card_id)
        
        # ä¿å­˜å¡å¯†åˆ°æ–‡ä»¶
        timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        file_name = f"vip_cards_{timestamp}.txt"
        file_content = "\n".join([f"{card_id} {vip_days}å¤©VIP" for card_id in generated_cards])
        
        bot.send_document(
            message.chat.id,
            io.BytesIO(file_content.encode('utf-8')),
            caption=(
                f"âœ… æˆåŠŸç”Ÿæˆ {count} å¼ VIPå¡å¯†!\n"
                f"æ¯å¼ å¡å€¼: {vip_days}å¤©VIPç‰¹æƒ\n"
                f"æœ‰æ•ˆæœŸ: {expires_in}å¤©\n\n"
                f"ä½¿ç”¨å‘½ä»¤: `/redeem å¡å·`"
            ),
            visible_file_name=file_name
        )
        
    except Exception as e:
        bot.reply_to(message, f"âŒ ç”Ÿæˆå¤±è´¥: {str(e)}")

def show_card_stats(message):
    c = conn.cursor()
    
    # æ€»ä½“ç»Ÿè®¡
    c.execute("SELECT COUNT(*) FROM recharge_cards")
    total_cards = c.fetchone()[0]
    
    c.execute("SELECT COUNT(*) FROM recharge_cards WHERE is_used = 1")
    used_cards = c.fetchone()[0]
    
    c.execute("SELECT COUNT(*) FROM recharge_cards WHERE expires_at < CURRENT_TIMESTAMP")
    expired_cards = c.fetchone()[0]
    
    # ç§¯åˆ†å¡ç»Ÿè®¡
    c.execute("SELECT COUNT(*), SUM(amount) FROM recharge_cards WHERE card_type = 'credits' AND is_used = 1")
    credit_stats = c.fetchone()
    credit_cards = credit_stats[0] or 0
    total_credits = credit_stats[1] or 0
    
    # VIPå¡ç»Ÿè®¡
    c.execute("SELECT COUNT(*), SUM(vip_days) FROM recharge_cards WHERE card_type = 'vip' AND is_used = 1")
    vip_stats = c.fetchone()
    vip_cards = vip_stats[0] or 0
    total_vip_days = vip_stats[1] or 0
    
    stats_msg = (
        f"ğŸ“Š *å¡å¯†ç³»ç»Ÿç»Ÿè®¡*\n\n"
        f"ğŸ”‘ æ€»å¡å¯†æ•°: {total_cards}\n"
        f"âœ… å·²ä½¿ç”¨: {used_cards}\n"
        f"âŒ› å·²è¿‡æœŸ: {expired_cards}\n"
        f"ğŸ”„ æœªä½¿ç”¨: {total_cards - used_cards - expired_cards}\n\n"
        f"ğŸª™ *ç§¯åˆ†å¡ç»Ÿè®¡*\n"
        f"â€¢ å·²ä½¿ç”¨: {credit_cards}å¼ \n"
        f"â€¢ æ€»å……å€¼ç§¯åˆ†: {total_credits}\n\n"
        f"ğŸŒŸ *VIPå¡ç»Ÿè®¡*\n"
        f"â€¢ å·²ä½¿ç”¨: {vip_cards}å¼ \n"
        f"â€¢ æ€»VIPå¤©æ•°: {total_vip_days}å¤©"
    )
    
    bot.send_message(message.chat.id, stats_msg, parse_mode='Markdown')

def export_cards(message):
    c = conn.cursor()
    
    # è·å–æ‰€æœ‰æœªä½¿ç”¨å¡å¯†
    c.execute("SELECT card_id, amount, card_type, vip_days, expires_at, note FROM recharge_cards WHERE is_used = 0")
    unused_cards = c.fetchall()
    
    if not unused_cards:
        bot.reply_to(message, "âŒ æ²¡æœ‰å¯å¯¼å‡ºçš„æœªä½¿ç”¨å¡å¯†")
        return
    
    # ç”Ÿæˆæ–‡ä»¶å†…å®¹
    file_content = "å¡å·,ç±»å‹,å€¼,æœ‰æ•ˆæœŸ,å¤‡æ³¨\n"
    for card in unused_cards:
        card_id, amount, card_type, vip_days, expires_at, note = card
        card_value = f"{amount}ç§¯åˆ†" if card_type == 'credits' else f"{vip_days}å¤©VIP"
        file_content += f"{card_id},{card_type},{card_value},{expires_at},{note}\n"
    
    # å‘é€æ–‡ä»¶
    bot.send_document(
        message.chat.id,
        io.BytesIO(file_content.encode('utf-8')),
        caption=f"âœ… æˆåŠŸå¯¼å‡º {len(unused_cards)} å¼ æœªä½¿ç”¨å¡å¯†",
        visible_file_name="unused_cards.csv"
    )

# ==================== ç®¡ç†å‘˜å‘½ä»¤ - æŸ¥çœ‹æ‰¹é‡ä»»åŠ¡ ====================
@bot.message_handler(commands=['batch_tasks'])
def list_batch_tasks(message):
    if str(message.from_user.id) != ADMIN_ID:
        return
    
    c = conn.cursor()
    c.execute("SELECT id, user_id, task_type, status, created_at, result_count FROM batch_tasks ORDER BY id DESC LIMIT 10")
    tasks = c.fetchall()
    
    if not tasks:
        bot.reply_to(message, "æš‚æ— æ‰¹é‡ä»»åŠ¡")
        return
    
    task_list = "ğŸ“‹ æœ€è¿‘æ‰¹é‡ä»»åŠ¡:\n\n"
    for task in tasks:
        task_id, user_id, task_type, status, created_at, result_count = task
        task_list += (
            f"ID: {task_id}\n"
            f"ç”¨æˆ·: {user_id}\n"
            f"ç±»å‹: {task_type}\n"
            f"çŠ¶æ€: {status}\n"
            f"æ—¶é—´: {created_at}\n"
            f"ç»“æœæ•°: {result_count or 0}\n"
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
        )
    
    bot.reply_to(message, task_list)

# ==================== ç®¡ç†å‘˜å‘½ä»¤ ====================
@bot.message_handler(commands=['stats'])
def system_stats(message):
    if str(message.from_user.id) != ADMIN_ID:
        return
    
    c = conn.cursor()
    
    # ç”¨æˆ·ç»Ÿè®¡
    c.execute("SELECT COUNT(*) FROM users")
    user_count = c.fetchone()[0]
    
    c.execute("SELECT SUM(credits) FROM users")
    total_credits = c.fetchone()[0] or 0
    
    # VIPç”¨æˆ·ç»Ÿè®¡
    c.execute("SELECT COUNT(*) FROM users WHERE vip_expiry > CURRENT_TIMESTAMP")
    vip_count = c.fetchone()[0]
    
    # æŸ¥è¯¢ç»Ÿè®¡
    c.execute("SELECT COUNT(*) FROM query_logs WHERE date(timestamp) = date('now')")
    daily_queries = c.fetchone()[0]
    
    # å¡å¯†ç»Ÿè®¡
    c.execute("SELECT COUNT(*) FROM recharge_cards")
    card_count = c.fetchone()[0]
    
    # æ•°æ®ç»Ÿè®¡
    c.execute("SELECT COUNT(*) FROM data_uploads")
    upload_count = c.fetchone()[0]
    
    # æ‰¹é‡ä»»åŠ¡ç»Ÿè®¡
    c.execute("SELECT COUNT(*) FROM batch_tasks")
    batch_count = c.fetchone()[0]
    
    # æ–‡ä»¶ç»Ÿè®¡
    c.execute("SELECT COUNT(*) FROM files")
    file_count = c.fetchone()[0]
    c.execute("SELECT COUNT(*) FROM files WHERE is_volume = 1")
    volume_file_count = c.fetchone()[0]
    
    stats_msg = (
        f"ğŸ“Š ç³»ç»Ÿç»Ÿè®¡\n\n"
        f"ğŸ‘¥ ç”¨æˆ·æ€»æ•°: {user_count} (VIP: {vip_count})\n"
        f"ğŸ’° ç³»ç»Ÿæ€»ç§¯åˆ†: {total_credits}\n"
        f"ğŸ”‘ å¡å¯†æ€»æ•°: {card_count}\n"
        f"ğŸ” ä»Šæ—¥æŸ¥è¯¢: {daily_queries}æ¬¡\n"
        f"ğŸ“¤ æ•°æ®æ›´æ–°: {upload_count}æ¬¡\n"
        f"ğŸ“‹ æ‰¹é‡ä»»åŠ¡: {batch_count}æ¬¡\n"
        f"ğŸ“ æ–‡ä»¶å­˜å‚¨: {file_count} (åˆ†å·: {volume_file_count})\n\n"
        f"ğŸ’¾ æ•°æ®åº“å¤§å°: {os.path.getsize('soc_data.db')/1024/1024:.2f} MB"
    )
    
    bot.reply_to(message, stats_msg)

@bot.message_handler(commands=['update_data'])
def update_data_command(message):
    if str(message.from_user.id) != ADMIN_ID:
        return
    
    bot.reply_to(
        message,
        "ğŸ“¤ è¯·ä¸Šä¼ æ•°æ®æ–‡ä»¶ (CSVæ ¼å¼)\n\n"
        "æ–‡ä»¶åæ ¼å¼: `åœ°åŒº_å¹´æœˆæ—¥.csv`\n"
        "ç¤ºä¾‹: `beijing_20250615.csv`\n\n"
        "æ–‡ä»¶å†…å®¹æ ¼å¼:\n"
        "å§“å,æ‰‹æœºå·,èº«ä»½è¯å·,æ•°æ®æ¥æº\n\n"
        "âš ï¸ æœ€å¤§æ”¯æŒ5MBæ–‡ä»¶",
        parse_mode='Markdown'
    )

# ==================== é”™è¯¯å¤„ç† ====================
@bot.message_handler(func=lambda message: True)
def handle_unknown(message):
    text = message.text.strip()
    
    # æ›´æ–°ç”¨æˆ·æ´»è·ƒæ—¶é—´
    update_user_last_active(message.from_user.id)
    
    # æ™ºèƒ½è¯†åˆ«ç±»ä¼¼å‘½ä»¤
    if text.startswith('/'):
        bot.reply_to(
            message,
            f"âš ï¸ æœªçŸ¥å‘½ä»¤: {text.split()[0]}\n"
            "ä½¿ç”¨ /help æŸ¥çœ‹å¯ç”¨å‘½ä»¤"
        )
    else:
        # å°è¯•çŒœæµ‹ç”¨æˆ·æ„å›¾
        if 'ç§¯åˆ†' in text or 'ç‚¹æ•°' in text:
            show_credits(message)
        elif 'ç­¾åˆ°' in text:
            check_in(message)
        elif 'æ ¸éªŒ' in text or 'éªŒè¯' in text:
            bot.reply_to(
                message,
                "ğŸ†” äºŒè¦ç´ æ ¸éªŒå‘½ä»¤:\n"
                "`/verify å§“å èº«ä»½è¯å·`\n"
                "ç¤ºä¾‹: `/verify å¼ ä¸‰ 110101199001011234`\n"
                "æ¶ˆè€—2ç§¯åˆ†/æ¬¡",
                parse_mode='Markdown'
            )
        elif 'æ‰¹é‡' in text or 'csv' in text:
            bot.reply_to(
                message,
                "ğŸ“‹ æ‰¹é‡æŸ¥è¯¢ä½¿ç”¨è¯´æ˜:\n"
                "1. ä½¿ç”¨å‘½ä»¤ `/batch` (æ¶ˆè€—10ç§¯åˆ†)\n"
                "2. ä¸Šä¼ CSVæ–‡ä»¶ï¼Œæ ¼å¼ä¸º:\n"
                "å‘½ä»¤,å‚æ•°1,å‚æ•°2,...\n"
                "ç¤ºä¾‹:\n"
                "`/my,123456,13800138000`\n"
                "`/verify,æå››,110101199001011234`\n"
                "3. ä¸‹è½½[æ¨¡æ¿æ–‡ä»¶](https://example.com/batch_template.csv)"
            )
        elif 'å¡å¯†' in text or 'å……å€¼' in text:
            bot.reply_to(
                message,
                "ğŸ”‘ å¡å¯†å…‘æ¢å‘½ä»¤:\n"
                "`/redeem å¡å·`\n\n"
                "VIPå¡å¯†å¯å…‘æ¢ä¼šå‘˜ç‰¹æƒï¼Œç§¯åˆ†å¡å¯†å¯å¢åŠ è´¦æˆ·ç§¯åˆ†"
            )
        elif 'æŸ¥è¯¢' in text or 'æŸ¥' in text:
            bot.reply_to(
                message,
                "ğŸ” è¯·ä½¿ç”¨å…·ä½“æŸ¥è¯¢å‘½ä»¤:\n"
                "â€¢ /my QQç»‘æ‰‹æœº (1ç§¯åˆ†)\n"
                "â€¢ /qe ç»¼åˆæŸ¥è¯¢ (3ç§¯åˆ†)\n"
                "â€¢ /yd äººå£æŸ¥è¯¢ (3ç§¯åˆ†)\n"
                "â€¢ /help æŸ¥çœ‹å…¨éƒ¨å‘½ä»¤"
            )
        elif 'ä¸ªäººä¸­å¿ƒ' in text or 'æˆ‘çš„ä¿¡æ¯' in text:
            user_profile(message)
        elif 'æ–‡ä»¶' in text or 'æœç´¢' in text:
            bot.reply_to(
                message,
                "ğŸ“ æ–‡ä»¶æ£€ç´¢å‘½ä»¤:\n"
                "`/search å…³é”®è¯`\n"
                "ç¤ºä¾‹: `/search ä¸Šæµ·å®¢æˆ·æ•°æ®`"
            )
        else:
            bot.reply_to(
                message,
                "ğŸ¤– æˆ‘æ˜¯è€çš®ç¤¾å·¥åº“æœºå™¨äºº\n"
                "è¾“å…¥ /help æŸ¥çœ‹ä½¿ç”¨æŒ‡å—\n"
                "è¾“å…¥ /kn æŸ¥çœ‹ä¸ªäººä¸­å¿ƒ"
            )

# ==================== ä¸»ç¨‹åºå…¥å£ ====================
if __name__ == '__main__':
    # å¯åŠ¨æ¶ˆæ¯
    print("æœºå™¨äººå¯åŠ¨ä¸­...")
    logging.info(f"æœºå™¨äººå¯åŠ¨ï¼Œç®¡ç†å‘˜ID: {ADMIN_ID}")
    
    try:
        bot.infinity_polling()
    except Exception as e:
        logging.error(f"æœºå™¨äººå¼‚å¸¸åœæ­¢: {str(e)}")
        # å‘é€è­¦æŠ¥ç»™ç®¡ç†å‘˜
        bot.send_message(ADMIN_ID, f"âš ï¸ æœºå™¨äººå¼‚å¸¸åœæ­¢: {str(e)}")